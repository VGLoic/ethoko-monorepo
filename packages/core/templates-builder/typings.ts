// THIS IS AN AUTOGENERATED FILE. EDIT AT YOUR OWN RISKS.
import fs from "node:fs/promises";
import fsSync from "node:fs";
import { PROJECTS, ETHOKO_PATH } from "./summary-exports";

type AccurateProject = keyof typeof PROJECTS;
export type Project = AccurateProject extends never ? string : AccurateProject;

export type Contract<TProject> = TProject extends AccurateProject
  ? keyof (typeof PROJECTS)[TProject]["contracts"]
  : string;
export type Tag<TProject> = TProject extends AccurateProject
  ? keyof (typeof PROJECTS)[TProject]["tags"]
  : string;

type AvailableTagForContractAsArray<TProject, TContract> =
  TProject extends AccurateProject
    ? TContract extends Contract<TProject>
      ? (typeof PROJECTS)[TProject]["contracts"][TContract]
      : string[]
    : string[];

export type AvailableTagForContract<TProject, TContract> =
  AvailableTagForContractAsArray<TProject, TContract>[number];

type AvailableContractsForTagAsArray<TProject, TTag> =
  TProject extends AccurateProject
    ? TTag extends Tag<TProject>
      ? (typeof PROJECTS)[TProject]["tags"][TTag]
      : string[]
    : string[];
export type AvailableContractForTag<TProject, TTag> =
  AvailableContractsForTagAsArray<TProject, TTag>[number];

export function project<TProject extends Project>(project: TProject) {
  return {
    /**
     * Get the available tags for the project
     * @returns The array of available tags
     */
    getAvailableTags(): Tag<TProject>[] {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      if (!(PROJECTS as any)[project]) {
        return [];
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return Object.keys((PROJECTS as any)[project].tags) as Tag<TProject>[];
    },
    /**
     * Get the available contracts for the project
     * @returns The array of available contracts. Each contract is formatted as "path/to/Contract.sol:Contract"
     */
    getAvailableContracts(): Contract<TProject>[] {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      if (!(PROJECTS as any)[project]) {
        return [];
      }
      return Object.keys(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (PROJECTS as any)[project].contracts,
      ) as Contract<TProject>[];
    },
    /**
     * Utility functions for a given contract
     * @param contractKey Key of the contract formatted as "path/to/Contract.sol:Contract"
     * @returns Utility functions for the given contract
     * @example ```typescript
     * const counterUtils = project("my-project").contract("src/Counter.sol:Counter");
     * const availableTags = counterUtils.getAvailableTags();
     * const counterArtifact = await counterUtils.getArtifact("v1.3.1");
     * ```
     */
    contract<TContract extends Contract<TProject>>(contractKey: TContract) {
      return {
        getArtifact(tag: AvailableTagForContract<TProject, TContract>) {
          return getArtifact(project, tag as string, contractKey as string);
        },
        getArtifactSync(tag: AvailableTagForContract<TProject, TContract>) {
          return getArtifactSync(project, tag as string, contractKey as string);
        },
        getAvailableTags(): AvailableTagForContractAsArray<
          TProject,
          TContract
        > {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          if (!(PROJECTS as any)[project]) {
            throw new Error(`Project ${project} not found`);
          }
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return (PROJECTS as any)[project].contracts[contractKey as string];
        },
      };
    },
    /**
     * Utility functions for a given tag
     * @param tag Tag
     * @returns Utility functions for the given tag
     * @example ```typescript
     * const v1_3_1Utils = project("my-project").tag("v1.3.1");
     * const availableContracts = v1_3_1Utils.getAvailableContracts();
     * const compilationArtifact = await v1_3_1Utils.getCompilationArtifact();
     * const incrementOracleArtifact = await v1_3_1Utils.getContractArtifact("src/IncrementOracle.sol:IncrementOracle");
     * ```
     */
    tag<TTag extends Tag<TProject>>(tag: TTag) {
      return {
        getContractArtifact(
          contractKey: AvailableContractForTag<TProject, TTag>,
        ) {
          return getArtifact(project, tag as string, contractKey as string);
        },
        getContractArtifactSync(
          contractKey: AvailableContractForTag<TProject, TTag>,
        ) {
          return getArtifactSync(project, tag as string, contractKey as string);
        },
        getAvailableContracts(): AvailableContractsForTagAsArray<
          TProject,
          TTag
        > {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          if (!(PROJECTS as any)[project]) {
            throw new Error(`Project ${project} not found`);
          }
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return (PROJECTS as any)[project].tags[tag];
        },
        getCompilationArtifact() {
          return getCompilationArtifact(project, tag as string);
        },
        getCompilationArtifactSync() {
          return getCompilationArtifactSync(project, tag as string);
        },
      };
    },
  };
}

async function getArtifact(
  project: string,
  tag: string,
  contractKey: string,
): Promise<ContractArtifact> {
  const buildInfoResult = await toAsyncResult(
    getCompilationArtifact(project, tag),
  );
  if (!buildInfoResult.success) {
    throw buildInfoResult.error;
  }

  return buildInfoToContractArtifact(
    project,
    tag,
    contractKey,
    buildInfoResult.value,
  );
}

function getArtifactSync(
  project: string,
  tag: string,
  contractKey: string,
): ContractArtifact {
  const buildInfo = getCompilationArtifactSync(project, tag);

  return buildInfoToContractArtifact(project, tag, contractKey, buildInfo);
}

function buildInfoToContractArtifact(
  project: string,
  tag: string,
  contractKey: string,
  buildInfo: EthokoBuildInfo,
): ContractArtifact {
  const contractPieces = contractKey.split(":");
  const contractName = contractPieces.at(-1);
  if (!contractName) {
    throw new Error(
      `Invalid contract key: ${contractKey}. Expected format: "path/to/Contract.sol:Contract"`,
    );
  }
  const contractPath = contractPieces.at(0);
  if (!contractPath) {
    throw new Error(
      `Invalid contract key: ${contractKey}. Expected format: "path/to/Contract.sol:Contract"`,
    );
  }
  const output = buildInfo.output;
  if (!output) {
    throw new Error(
      `Contracts output not found for artifact ${project}:${tag}`,
    );
  }
  const contractPathContracts = output.contracts[contractPath];
  if (!contractPathContracts) {
    throw new Error(
      `Contract artifact not found for contract key: ${contractKey} with artifact ${project}:${tag}`,
    );
  }
  const contractArtifact = contractPathContracts[contractName];
  if (!contractArtifact) {
    throw new Error(
      `Contract artifact not found for contract key: ${contractKey} with artifact ${project}:${tag}`,
    );
  }
  return {
    _format: "ethoko-artifact-v0",
    abi: contractArtifact.abi,
    metadata: contractArtifact.metadata || "",
    bytecode: prefixWith0x(contractArtifact.evm.bytecode.object),
    deployedBytecode: contractArtifact.evm.deployedBytecode?.object
      ? prefixWith0x(contractArtifact.evm.deployedBytecode.object)
      : "0x",
    linkReferences: contractArtifact.evm.bytecode.linkReferences,
    deployedLinkReferences: contractArtifact.evm.deployedBytecode
      ? contractArtifact.evm.deployedBytecode.linkReferences
      : {},
    contractName,
    sourceName: contractPath,
    userdoc: contractArtifact.userdoc,
    devdoc: contractArtifact.devdoc,
    storageLayout: contractArtifact.storageLayout,
    evm: contractArtifact.evm,
  };
}

function prefixWith0x(s: string): `0x${string}` {
  if (s.startsWith("0x")) return s as `0x${string}`;
  return `0x${s}`;
}

/**
 * Get a compilation artifact
 * @param project Related project
 * @param tag Tag of the compilation
 * @returns The compilation artifact
 */
async function getCompilationArtifact(
  project: string,
  tag: string,
): Promise<EthokoBuildInfo> {
  const buildInfoExists = await fs
    .stat(`${ETHOKO_PATH}/${project}/tags/${tag}.json`)
    .catch(() => false);
  if (!buildInfoExists) {
    throw new Error(`artifact not found for "${project}:${tag}". Skipping`);
  }
  const buildInfoContentResult = await toAsyncResult(
    fs
      .readFile(`${ETHOKO_PATH}/${project}/tags/${tag}.json`, "utf-8")
      .then(JSON.parse),
  );
  if (!buildInfoContentResult.success) {
    console.error(buildInfoContentResult.error);
    throw buildInfoContentResult.error;
  }

  return buildInfoContentResult.value;
}

/**
 * Get a compilation artifact
 * @param project Related project
 * @param tag Tag of the compilation
 * @returns The compilation artifact
 */
function getCompilationArtifactSync(
  project: string,
  tag: string,
): EthokoBuildInfo {
  try {
    fsSync.statSync(`${ETHOKO_PATH}/${project}/tags/${tag}.json`);
  } catch {
    throw new Error(`artifact not found for "${project}:${tag}". Skipping`);
  }

  try {
    const buildInfoContent = fsSync.readFileSync(
      `${ETHOKO_PATH}/${project}/tags/${tag}.json`,
      "utf-8",
    );
    const jsonContent = JSON.parse(buildInfoContent);
    return jsonContent as EthokoBuildInfo;
  } catch (e) {
    console.error(e);
    throw e;
  }
}

function toAsyncResult<T, TError = Error>(
  promise: Promise<T>,
  opts: {
    debug?: boolean;
  } = {},
): Promise<{ success: true; value: T } | { success: false; error: TError }> {
  return promise
    .then((value) => ({ success: true as const, value }))
    .catch((error) => {
      if (opts.debug) {
        console.error(error);
      }
      return { success: false as const, error };
    });
}

// #############################################################
// ##################### Compilation types #####################
// #############################################################

export interface EthokoBuildInfo {
  id: string;
  solcLongVersion: string;
  origin: {
    id: string;
    format: string;
    outputFormat?: string;
  };
  input: CompilerInput;
  output: CompilerOutput;
}

interface CompilerInput {
  language: string;
  sources: { [sourceName: string]: InputSource };
  settings?: InputSettings;
}

type InputSource =
  | {
      license?: string;
      keccak256?: string;
      urls?: string[];
      content?: string;
    }
  | {
      ast: Record<string, unknown>;
    }
  | {
      assemblyJson: {
        ".code": unknown[];
        ".data"?: Record<string, unknown>;
        sourceList?: string[];
      };
    };

interface InputSettings {
  stopAfter?: string;
  remappings?: string[];
  optimizer?: OptimizerSettings;
  evmVersion?: string;
  eofVersion?: number;
  viaIr?: boolean;
  debug?: unknown;
  metadata?: unknown;
  libraries?: Record<string, Record<string, string>>;
  outputSelection?: unknown;
  modelChecker?: unknown;
}
interface OptimizerSettings {
  enabled?: boolean;
  runs?: number;
  details?: unknown;
}

interface CompilerOutput {
  errors?: unknown[];
  sources?: CompilerOutputSources;
  contracts: {
    [sourceName: string]: {
      [contractName: string]: CompilerOutputContract;
    };
  };
}

interface CompilerOutputSources {
  [sourceName: string]: CompilerOutputSource;
}

interface CompilerOutputSource {
  id: number;
  ast: unknown;
}

interface CompilerOutputContract {
  abi: unknown[];
  metadata: string;
  userdoc?: unknown;
  devdoc?: unknown;
  ir?: string;
  irAst?: unknown;
  irOptimized?: string;
  irOptimizedAst?: unknown;
  storageLayout?: unknown;
  transientStorageLayout?: unknown;
  evm: {
    assembly?: string;
    legacyAssembly?: unknown;
    bytecode: CompilerOutputBytecode;
    deployedBytecode?: CompilerOutputBytecode & {
      immutableReferences?: unknown;
    };
    methodIdentifiers?: {
      [methodSignature: string]: string;
    };
    gasEstimates?: {
      creation?: Record<string, string>;
      external?: Record<string, string>;
      internal?: Record<string, string>;
    };
  };
}

interface CompilerOutputBytecode {
  functionDebugData?: unknown;
  object: string;
  opcodes?: string;
  sourceMap?: string;
  generatedSources?: unknown[];
  linkReferences: LinkReferences;
}

interface LinkReferences {
  [libraryFileName: string]: {
    [libraryName: string]: Array<{ length: number; start: number }>;
  };
}

// ##############################################
// ################# Built type #################
// ##############################################

/**
 * This interface is derived from the compilation output.
 *
 * It is meant to integrate in a smoother way with external dependencies.
 */
export interface ContractArtifact {
  /**
   * Format, hardcoded to `ethoko-artifact-v0` for now
   */
  readonly _format: "ethoko-artifact-v0";
  /**
   * ABI of the artifact
   */
  readonly abi: unknown[];
  /**
   * Metadata of the artifact, fallback to empty string
   */
  readonly metadata: string;
  /**
   * Bytecode formatted with `0x` prefix
   */
  readonly bytecode: `0x${string}`;
  /**
   * Deployed bytecode, formatted with `0x` prefix, fallback to `0x`
   */
  readonly deployedBytecode: `0x${string}`;
  /**
   * Link references for the libraries
   */
  readonly linkReferences: LinkReferences;
  /**
   * Link references for the deployed libraries, fallback to empty object
   */
  readonly deployedLinkReferences: LinkReferences;
  /**
   * Name of the contract
   */
  readonly contractName: string;
  /**
   * Relative path
   */
  readonly sourceName: string;
  /**
   * User documentation
   */
  readonly userdoc?: unknown;
  /**
   * Dev documentation
   */
  readonly devdoc?: unknown;
  /**
   * Storage layout
   */
  readonly storageLayout?: unknown;
  /**
   * Full EVM compilation output object
   */
  readonly evm: {
    readonly assembly?: string;
    readonly bytecode: CompilerOutputBytecode;
    readonly deployedBytecode?: CompilerOutputBytecode;
    readonly gasEstimates?: {
      readonly creation?: Record<string, string>;
      readonly external?: Record<string, string>;
      readonly internal?: Record<string, string>;
    };
    readonly methodIdentifiers?: {
      readonly [methodSignature: string]: string;
    };
  };
}
