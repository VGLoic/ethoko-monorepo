import z from "zod";
import { JsonSchema } from "../json";
import { SettingsSchema } from "./input-json";

// This file contains the Zod schema for the output JSON structure as output by the Solidity compiler (solc).
// Fields and comments are copied from https://docs.soliditylang.org/en/v0.8.33/using-the-compiler.html#output-description

const ErrorSchema = z.object({
  // Optional: Location within the source file.
  sourceLocation: z
    .object({
      file: z.string(),
      start: z.number(),
      end: z.number(),
    })
    .optional(),
  // Optional: Further locations (e.g. places of conflicting declarations)
  secondarySourceLocations: z
    .array(
      z.object({
        file: z.string(),
        start: z.number(),
        end: z.number(),
        message: z.string().optional(),
      }),
    )
    .optional(),
  // Mandatory: Error type, such as "TypeError", "InternalCompilerError", "Exception", etc.
  // See below for complete list of types.
  type: z.string(),
  // Mandatory: Component where the error originated, such as "general" etc.
  component: z.string(),
  // Mandatory ("error", "warning" or "info", but please note that this may be extended in the future)
  severity: z.string(),
  // Optional: unique code for the cause of the error
  errorCode: z.string().optional(),
  // Mandatory
  message: z.string(),
  // Optional: the message formatted with source location
  formattedMessage: z.string().optional(),
});

const SourceSchema = z.object({
  // Identifier of the source (used in source maps)
  id: z.number(),
  // The AST object
  ast: JsonSchema,
});

// Schema is derived from the documentation https://docs.soliditylang.org/en/develop/abi-spec.html#json
const ComponentSchema = z.unknown();
const EventItemSchema = z.object({
  type: z.literal("event"),
  name: z.string(),
  inputs: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
      components: z.array(ComponentSchema).optional(),
      indexed: z.boolean(),
    }),
  ),
  anonymous: z.boolean(),
});
const ErrorItemSchema = z.object({
  type: z.literal("error"),
  name: z.string(),
  inputs: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
      components: z.array(ComponentSchema).optional(),
    }),
  ),
});
const ItemOutputInputSchema = z.object({
  name: z.string(),
  type: z.string(),
  components: z.array(ComponentSchema).optional(),
});
const FunctionItemSchema = z.object({
  type: z.literal("function"),
  name: z.string(),
  inputs: z.array(ItemOutputInputSchema),
  outputs: z.array(ItemOutputInputSchema),
  stateMutability: z.enum(["pure", "view", "nonpayable", "payable"]),
});
const ConstructorItemSchema = z.object({
  type: z.literal("constructor"),
  inputs: z.array(ItemOutputInputSchema),
  stateMutability: z.enum(["pure", "view", "nonpayable", "payable"]),
});
const FallbackItemSchema = z.object({
  type: z.literal("fallback"),
  stateMutability: z.enum(["pure", "view", "nonpayable", "payable"]),
});
const ReceiveItemSchema = z.object({
  type: z.literal("receive"),
  stateMutability: z.enum(["pure", "view", "nonpayable", "payable"]),
});
export const AbiItemSchema = z.discriminatedUnion("type", [
  EventItemSchema,
  ErrorItemSchema,
  FunctionItemSchema,
  ConstructorItemSchema,
  FallbackItemSchema,
  ReceiveItemSchema,
]);

export const BytecodeSchema = z.object({
  // Debugging data at the level of functions.
  functionDebugData: JsonSchema.optional(),
  // The bytecode as a hex string.
  object: z.string(),
  // Opcodes list (string)
  opcodes: z.string().optional(),
  // The source mapping as a string. See the source mapping definition.
  sourceMap: z.string().optional(),
  // Array of sources generated by the compiler. Currently only
  // contains a single Yul file.
  generatedSources: z.array(JsonSchema).optional(),
  // If given, this is an unlinked object.
  linkReferences: z.record(
    z.string(), // File name
    z.record(
      z.string(), // Library name
      z.array(
        z.object({
          start: z.number(),
          length: z.number(),
        }),
      ),
    ),
  ),
});

/**
 * This is the schema for the JSON structure of the "metadata" field of the contract output as output by the Solidity compiler (solc).
 *
 * Fields and comments are copied from https://docs.soliditylang.org/en/v0.8.33/metadata.html
 */
export const ContractMetadataSchema = z.object({
  // Required: Details about the compiler, contents are specific to the language.
  compiler: z.object({
    // Optional: Hash of the compiler binary which produced this output
    keccak256: z.string().optional(),
    // Required for Solidity: Version of the compiler
    version: z.string(),
  }),
  // Required: Source code language, basically selects a "sub-version" of the specification
  language: z.enum(["Solidity", "Yul", "SolidityAST", "EVMAssembly"]),
  // Required: Generated information about the contract.
  output: z.object({
    // Required: ABI definition of the contract. See "Contract ABI Specification"
    abi: z.array(AbiItemSchema),
    // Required: NatSpec developer documentation of the contract. See https://docs.soliditylang.org/en/latest/natspec-format.html for details.
    devdoc: JsonSchema.optional(),
    // Required: NatSpec user documentation of the contract. See "NatSpec Format"
    userdoc: JsonSchema.optional(),
  }),
  // Required: Compiler settings.
  // Reflects the settings in the JSON input during compilation, except:
  // - Different format: "libraries" field
  // - Added field in metadata.settings: "compilationTarget"
  // - Not in metadata.settings: "stopAfter", "debug.debugInfo", "outputSelection"
  // See the standard JSON input's "settings" field docs for the rest.
  settings: SettingsSchema.omit({
    stopAfter: true,
    debug: true,
    outputSelection: true,
    libraries: true,
  }).extend({
    // Required for Solidity: File path and the name of the contract or library this
    // metadata is created for. This field is not present in the standard JSON input settings.
    compilationTarget: z.record(z.string(), z.string()).optional(),
    // Required for Solidity: Addresses for libraries used.
    // Note that metadata has a different format for "libraries" field than the standard JSON input.
    // metadata format = { "MyLib.sol:MyLib": "0x123123..." }
    // standard JSON input format = { "MyLib.sol": { "MyLib": "0x123123..." } }
    libraries: z.record(z.string(), z.string()).optional(),
  }),
  // Required: Compilation source files/source units, keys are file paths
  sources: z.record(z.string(), SourceSchema),
  // Required: The version of the metadata format
  version: z.number(),
});

export const SolcContractSchema = z.object({
  // The Ethereum Contract ABI. If empty, it is represented as an empty array.
  // See https://docs.soliditylang.org/en/develop/abi-spec.html
  abi: z.array(AbiItemSchema),
  // See the Metadata Output documentation (serialised JSON string)
  metadata: z.string(),
  // User documentation (natspec)
  userdoc: JsonSchema.optional(),
  // Developer documentation (natspec)
  devdoc: JsonSchema.optional(),
  // Intermediate representation before optimization (string)
  ir: z.string().optional(),
  // AST of intermediate representation before optimization
  irAst: JsonSchema.optional(),
  // Intermediate representation after optimization (string)
  irOptimized: z.string().optional(),
  // AST of intermediate representation after optimization
  irOptimizedAst: JsonSchema.optional(),
  // See the Storage Layout documentation.
  storageLayout: JsonSchema.optional(),
  // See the Storage Layout documentation.
  transientStorageLayout: JsonSchema.optional(),
  // EVM-related outputs
  evm: z.object({
    // Assembly (string)
    assembly: z.string().optional(),
    // Old-style assembly (object)
    legacyAssembly: JsonSchema.optional(),
    // Bytecode and related details.
    bytecode: BytecodeSchema,
    deployedBytecode: BytecodeSchema.extend({
      immutableReferences: JsonSchema.optional(),
    }),
    // The list of function hashes
    methodIdentifiers: z.record(z.string(), z.string()).optional(),
    // Function gas estimates
    gasEstimates: z
      .object({
        creation: z.record(z.string(), z.string()).optional(),
        external: z.record(z.string(), z.string()).optional(),
        internal: z.record(z.string(), z.string()).optional(),
      })
      .optional(),
  }),
});

/**
 * This is the schema for the output JSON structure as output by the Solidity compiler (solc).
 * Fields and comments are copied from https://docs.soliditylang.org/en/v0.8.33/using-the-compiler.html#output-description
 *
 * Taken at version v0.8.33
 */
export const SolcJsonOutputSchema = z.object({
  // Optional: not present if no errors/warnings/infos were encountered
  errors: z.array(ErrorSchema).optional(),
  // This contains the file-level outputs.
  // It can be limited/filtered by the outputSelection settings.
  sources: z.record(z.string(), SourceSchema).optional(),
  // This contains the contract-level outputs.
  // It can be limited/filtered by the outputSelection settings.
  contracts: z.record(
    z.string(), // Source file name
    z.record(
      z.string(), // Contract name
      SolcContractSchema,
    ),
  ),
});
