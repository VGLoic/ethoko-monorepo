import z from "zod";
import { HardhatUserConfig } from "hardhat/config";
import { HardhatConfig } from "hardhat/types/config";
import { HardhatUserConfigValidationError } from "hardhat/types/hooks";

/**
 * The Ethoko Hardhat user configuration
 */
export type EthokoHardhatUserConfig = {
  /**
   * The project name
   */
  project: string;
  /**
   * The local path in which artifacts will be pulled
   *
   * Default to `.ethoko`
   */
  pulledArtifactsPath?: string;
  /**
   * The local path in which typings will be generated
   *
   * Default to `.ethoko-typings`
   */
  typingsPath?: string;
  /**
   * The path to compilation output artifacts
   *
   * E.g. "./artifacts" for Hardhat, "./out" for Foundry
   *
   * When set, makes the --artifact-path flag optional for push and diff commands
   */
  compilationOutputPath?: string;
  /**
   * Configuration of the storage where the artifacts will be stored
   */
  storageConfiguration:
    | {
        type: "aws";
        awsRegion: string;
        awsBucketName: string;
        awsAccessKeyId: string;
        awsSecretAccessKey: string;
        awsRole?: {
          roleArn: string;
          externalId?: string;
          sessionName?: string;
          durationSeconds?: number;
        };
      }
    | {
        type: "local";
        path: string;
      };
  /**
   * Enable debug mode for all tasks
   *
   * Default to `false`
   */
  debug?: boolean;
};

export const EthokoHardhatConfigSchema = z.object({
  project: z.string().min(1),
  pulledArtifactsPath: z.string().default(".ethoko"),
  typingsPath: z.string().default(".ethoko-typings"),
  compilationOutputPath: z.string().optional(),
  storageConfiguration: z.discriminatedUnion("type", [
    z.object({
      type: z.literal("aws"),
      awsRegion: z.string().min(1),
      awsBucketName: z.string().min(1),
      awsAccessKeyId: z.string().min(1),
      awsSecretAccessKey: z.string().min(1),
      awsRole: z
        .object({
          roleArn: z.string().min(1),
          externalId: z.string().min(1).optional(),
          sessionName: z.string().min(1).default("ethoko-hardhat-session"),
          durationSeconds: z.number().int().min(900).max(43200).default(3600),
        })
        .optional(),
    }),
    z.object({
      type: z.literal("local"),
      path: z.string().min(1),
    }),
  ]),
  debug: z.boolean().default(false),
});

/**
 * This function validates the parts of the HardhatUserConfig that are relevant
 * to the plugin.
 *
 * This function is called from the `validateUserConfig` Hook Handler.
 *
 * @param userConfig The HardhatUserConfig, as exported in the config file.
 * @returns An array of validation errors, or an empty array if valid.
 */
export async function validatePluginConfig(
  userConfig: HardhatUserConfig,
): Promise<HardhatUserConfigValidationError[]> {
  if (userConfig.ethoko === undefined) {
    // If there's no networks field or it's invalid, we don't validate anything
    // in this plugin
    return [];
  }

  const parsingResult = EthokoHardhatConfigSchema.safeParse(userConfig.ethoko);
  if (!parsingResult.success) {
    const errors: HardhatUserConfigValidationError[] =
      parsingResult.error.errors.map((zodError) => ({
        path: ["ethoko", ...zodError.path],
        message: zodError.message,
      }));
    return errors;
  }

  return [];
}

/**
 * Resolves the plugin config, based on an already validated HardhatUserConfig
 * and a partially resolved HardhatConfig.
 *
 * This function is called from the `resolveUserConfig` Hook Handler.
 *
 * @param userConfig The HardhatUserConfig.
 * @param partiallyResolvedConfig The partially resolved HardhatConfig, which is
 *  generated by calling `next` in the `resolveUserConfig` Hook Handler.
 * @returns The resolved HardhatConfig.
 */
export async function resolvePluginConfig(
  userConfig: HardhatUserConfig,
  partiallyResolvedConfig: HardhatConfig,
): Promise<HardhatConfig> {
  if (userConfig.ethoko === undefined) {
    // If there's no ethoko field, we return the config as is
    return partiallyResolvedConfig;
  }

  // Else, the parse is guaranteed to succeed, because the config is already validated in the
  const ethokoConfig = EthokoHardhatConfigSchema.parse(userConfig.ethoko);

  return {
    ...partiallyResolvedConfig,
    ethoko: ethokoConfig,
  };
}
